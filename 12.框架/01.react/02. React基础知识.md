### 1.  为什么选择使用框架而不是原生？(为什么选择react)

```
优点：
	1. 组件化: 其中以 React 的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。
	2. 天然分层: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。
	3. 生态: 现在主流前端框架都自带生态,不管是数据流管理架构还是 UI 库都有成熟的解决方案。
	4. 开发效率: 现代前端框架都默认自动更新DOM,而非我们手动操作,解放了开发者的手动DOM成本,提高开发效率,从根本上解决了UI 与状态同步问题.
```

我选择react是 因为 ：

jsx写起来舒服、虚拟Dom的优点，diff 渲染，性能高效、useSate数据不可变 返回新的数据、react可以用redux 数据流更好管理、组件化思想

### 2. React Hooks 与 class 组件相比，有什么优点？(为什么要用hooks)

```
Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。现在很多大厂都已经全面升级react hooks 能熟练运用hooks 会成为你的加分项 
1. class 组件在组件之间复用状态逻辑很难,而 Hook 使你在无需修改组件结构的情况下复用状态逻辑。
2. class 组件的复杂组件变得难以理解。
3. class 难以理解，Hook 使你在非 class 的情况下可以使用更多的 React 特性。 
4. 极大地减少了代码量。
```

我选择用hooks是因为：使用ReactHooks无需复杂的DOM结构。

我们都知道React的核心思想就是，将一个页面拆分成一堆独立的，可以复用的组件，并且用自上而下的单向数据流的形式将这些组件串联起来。但如果在大型的项目中使用React，那么我们就会发现项目中实际上很多React组件冗长且难以复用。尤其是那些写成class的组件，他们本身本来就包含了状态（state），所以复用这类组件就变得很麻烦。

### 3. react  class组件的生命周期

![img](https://upload-images.jianshu.io/upload_images/9014816-37edd5c87c5bf503.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

```markdown
目前 react 的生命周期分为三个阶段，分别是 挂载阶段、更新阶段、卸载阶段
- 挂载阶段(初始化渲染)
  1. constructor ：构造函数，最先被执行，通过给 this.state 赋值对象来初始化内部 state
  2. render( )：这个方法必须返回一个JSX元素，用来重新渲染组件。render() 函数应该为纯函数，这意味着在不修改组件 state 的情况下，每次调用时都返回相同的结果，render( )不直接与浏览器交互。
  3. componentDidMount ：在组件挂载后(插入DOM树)立即调用，此时可以操作 Dom 请求数据
- 更新阶段
  1.shouldComponentUpdate 通常来优化 react 性能，判断组件是否需要渲染
  2. render( )
  3. componentDidUpdate 页面更新后立即调用
- 卸载阶段
  1. componentWillUnmount 组件销毁或卸载时调用，可以用来清除定时器，取消网络请求等操作。
被废弃的： componentWillMount componentWillUpdate
```

### 4. component 和 pureComponent 的区别，使用时有什么要注意的地方。

```
	React.PureComponent 与 React.Component很相似。两者区别在于：purecomponent 通过state和props的浅比较 来实现shouldCompoentUpdata()组件是否要更新。Component不会比较当前和下个状态的props和state，并未实现 shouldComponentUpdate()。
	如果赋予 React 组件相同的 props 和 state，render() 函数会渲染相同的内容，那么在某些情况下使用 React.PureComponent 可提高性能。
```

```
	React.PureComponent 中的 shouldComponentUpdate() 仅作对象的浅层比较。如果对象中包含复杂的数据结构，则有可能因为无法检查深层的差别，产生错误的比对结果。仅在你的 props 和 state 较为简单时，才使用 React.PureComponent，或者在深层数据结构发生变化时调用 forceUpdate() 来确保组件被正确地更新。你也可以考虑使用 immutable 对象加速嵌套数据的比较。
	此外，React.PureComponent 中的 shouldComponentUpdate() 将跳过所有子组件树的 prop 更新。因此，请确保所有子组件也都是“纯”的组件。
```

### 5. React.memo 与 pureComponent 的区别

```
	memo 为高阶组件，通过记忆组件渲染结果的方式来提高组件的性能表现。
	memo 仅检查 props 变更。如果函数组件被 React.memo 包裹，且其实现中拥有 useState 或 useContext 的 Hook，当 context 发生变化时，它仍会重新渲染。
	React.memo（只能用在 function component 上）默认对 props 浅比较。如果我们想要控制对比过程，可以将自定义的比较函数通过第二个参数传入来实现。通过第二个参数指定一个自定义的方法 来判断两次 props 有什么不同，memo会帮我们缓存上一个值，当我们接收一个新的值之后，两个值进行比较，相同的话，拒绝修改，直接使用已经缓存的值，不同的话， 则改变。
	
	pureComponent 是 react 官方将shouldComponentUpdate() 函数封装的好的组件。其中的shouldComponentUpdate() 也仅作对象的浅层比较。如果对象中包含复杂的数据结构，则会产生错误的比对结果。如果我们要优化的话，可以使用 Immutable 数据结构。
	需要注意的是：
shouldComponentUpdate  返回 false 组件就不会重新渲染， 默认返回 true 才会重新渲染
memo 返回 true 不会重新渲染，返回 false 才会重新渲染，因为 他是将上一次的props与这次的props作比较 相同返回 true 不同返回 false。
```

### 6.useMemo 和 useCallBack 的区别

```
同：useMemo 和 useCallback 都接收两个参数,第一个参数为回调，第二个参数为要依赖的数据
	有共同作用：都有缓存的作用，仅仅 依赖数据 发生变化, 才会重新计算结果
异：
1. usememo 用来缓存值(计算结果的值)，当 组件内部某一个渲染的数据，需要通过计算而来，这个计算是依赖与特定的state、props数据，我们就用useMemo来缓存这个数据，让函数在依赖不改变的情况下，不对这个值进行重新计算。
2. usecallback 是对一个**函数进行缓存**，用于子组件引用父组件的函数，父组件重新渲染，子组件不会因为这个函数的变动重新渲染。和React.memo搭配使用

1. useMemo优化的是函数进行运算的开销
2. useCallback优化的是组件重新渲染的开销
```

### 7. React.lazy 和 React.Suspense

```javascript
React.lazy() 允许你定义一个动态加载的组件。这有助于缩减 bundle 的体积，并延迟加载在初次渲染时未用到的组件。

// 这个组件是动态加载的
const SomeComponent = React.lazy(() => import('./SomeComponent'));

渲染 lazy 组件依赖该组件渲染树上层的 <React.Suspense> 组件。这是指定加载指示器（loading indicator）的方式。
```

```javascript
React.Suspense 可以指定加载指示器（loading indicator），以防其组件树中的某些子组件尚未具备渲染条件。目前，懒加载组件是 <React.Suspense> 支持的唯一用例：

// 该组件是动态加载的
const OtherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    // 显示 <Spinner> 组件直至 OtherComponent 加载完成
    <React.Suspense fallback={<Spinner />}>
      <div>
        <OtherComponent />
      </div>
    </React.Suspense>
  );
}
```

### 8. setState 到底是异步还是同步？

1. setState只在**合成事件和钩子函数(生命周期)**中是**异步**的，在**原生事件(addEventListener)和 setTimeout **中都是**同步**的。
2. setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中**没法立马拿到更新后的值**，形成了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。
3. setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，在更新时会对其进行合并批量更新。

### 9.  使用 styled-components的优点

```
更加灵活，让react更加组件化，增强了 html css js 的内聚性。方便复用，类名不冲突
由于使用模板字符串，我们也可以进行传参，使用js 来控制样式。
```

### 10. 什么是 Immutable？Immutable 数据的优势？

![img](https://user-gold-cdn.xitu.io/2019/10/20/16de7a154c8b30b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

```
因为 JavaScript 中的对象一般是可变的(Mutable)，因为使用了引用赋值，新的对象简单的引用了原来的对象，改变新的对象将影响到原来的对象。虽然这样做可以节约内存，但当应用复杂后，这就造成了非常大的隐患。为了解决这个问题，一般的做法是使用 shallowCopy（浅拷贝）或 deepCopy（深拷贝）来避免被修改，但这样做造成了 CPU 和内存的浪费。

而Immutable 可以很好地解决这些问题
Immutable 数据 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。Immutable 实现的原理是(持久化数据结构)，也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 深拷贝 把所有节点都复制一遍带来的性能损耗，Immutable 使用了结构共享，即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。

优点：
1. Immutable 降低了 Mutable 带来的复杂度
2. 结构共享 节省内存
3. Undo/Redo，Copy/Paste，甚至时间旅行这些功能做起来小菜一碟
4. 拥抱函数式编程 Immutable 本身就是函数式编程中的概念，纯函数式编程比面向对象更适用于前端开发。
```

