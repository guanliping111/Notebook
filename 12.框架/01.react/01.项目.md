###  1. 你在写项目遇到什么难点

- 数据分页返回

  因为我的项目是用 mocker-api 模拟的, 所以我在处理数据分页的时候遇到了一些困难，

  然后我通过网上查资料，发现可以获取 前端传过来的queryString参数从而获取到 offset偏移量的值

  然后我们在后端通过这个offset 对我们的数组进行切割处理，使用数组的 slice方法(这里有个坑就是我们从queryString取出来的参数是字符串，我们需要将其转化为Number型才能正确的切割转换数字型的方法， parseInt(parseInt 有两个参数，第一个参数是要转换的数，第二个参数是基数，如果第二个参数不传，默认基数为10) Number +号（利用弱类型转化）

  )，这样我们就达到了数据分页处理的功能。

- 实现上拉刷新，下拉加载功能。

  这个我一开始没有头绪，后来看了神三元的react-hooks小册，发现可以使用 better-scroll这个包，通过better-scroll的 pullUp 和 pullDown 方法 监听 上拉和下拉动作，实现这两个功能。通过上拉使offset的值设置为0，实现重新刷新的功能，通过下拉加载每次使offset的值+10，达到每次获取下10条数据，同时，在redux中，我们获取新数据的时候，会把老的数据先取出来，再把新的数据和老的数据合并，这样使我们在刷新过程中，老的数据不会丢失。

  debounce 实现？理解，我觉得debounce 好比电梯关门·，当没人出入的时候，电梯就会计时关门，当这个期间又有人进入时，电梯又会重新计时。 手写debounce 函数， 主要用在上拉和下拉这两个动作的防抖。

- 详情页数据的筛选

  详情页数据我查看了极客时间的网站，发现他是按照每个数据的id来作为子路由的，于是我试着模仿了一下，当我们点击详情页列表数据的时候，通过react-router-dom 的 NavLink 组件 把 to带上我们的id值，跳转到对应的页面，然后后端我通过req.params 把 id 解构出来，后端根据这个id对数据进行filter处理。得到了每个详情页面的数据。tab页的切换也是使用了和数据分页相同的思想，每次根据传回来的 tab值的不同，对数据进行不同的处理。

- 使用Immutable.js 重新弄了下 redux 中的数据。

- **页面交互**：	
  
  1. 账户页面
  
  首页在页面埋下一个id值。通过回调函数handleClick  点击获取id 改变背景色，同时用useState设置保存原来的state的值，当点击下一个，改变背景色，同时，还原上一个state的背景色，实现每次点击都改变背景色的效果。
  
  2. 支付台
  
  怎么判断余额是否充足的问题。用useState初始化状态为false，if 判断 为setnotEnough或setpaySuccess

- **redux的设计** 

  store  redux做数据流管理

  redux是为了解决react组件间通信和组件间状态共享而提出的一种解决方案

![img](https://pics0.baidu.com/feed/bd3eb13533fa828b575e7ddca365cd30970a5a0b.jpeg?token=78242bf3a90828d6c53cda4e82111a28&s=0881C7167DCDC90D1E50A9CB020030F1)

### 2. 你的项目请求后端接口的时候， 数据是怎么请求的？(请求数据存到redux过程)

- 定义接口 axios

  在api目录下， 用axios定义了接口函数，通过这个函数.get 得到 URL 获取我们需要的数据

-  用redux请求数据  流程

  Redux有3大核心概念 Store Action Reducer

  ```markdown
  1. Store：保存数据的地方，可以把它看成一个容器。Store对象包含所有数据。store里面有很多state 表示数据的状态(某个时间点的数据集合就叫做State)
  我们通过redux当中的createStore方法来创建一个store。
  
  2. Action：State的变化，会导致UI页面(组件)的变化。但是，用户接触不到State，只能接触到ui。所以，State的变化必须是UI导致的。Action就是UI发出的通知，表示State应该要发生变化了。
  ActionCreator：一个函数用来生成Action的。
  
  3. Reducer：Reducer是一个函数，它接受Action和当前State作为参数，返回一个新的State。Store收到Action以后，必须给出一个新的State，这样UI页面才会发生变化。这种State的计算过程就叫做Reducer。
  纯函数: 一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用
  
  4. dispatch：UI操作state 必须发出action，是UI页面发出Action的唯一方法。
  
  然后我们过下整个工作流程：
  
  首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
  然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State
  State一旦有变化，Store就会调用监听函数，来更新View。
  ```
  
  然后在我的项目中
  
  1. 首先定义 action的常量 
  
  2. 在reducer里面定义数组用于存储, 导入定义的常量actionTypes。
  
     在reducer里面通过switch case，并返回修改的数据
  
  3. 在actionCreators里面定义getXXXAction，进行数据请求 。定义changeXXXAction供getXXXAction使用
  
     首先定义一个getXXXAction函数来获取要请求的数据，通过dispatch来获取用户在页面发出的action，
  
     通过接口函数获取的数据data返回给客户端。如果数据发送了改变，通过我们定义的changeXXXAction函数，接收数据,通过里面的type和data来获取新的数据。
  
  4. 最后在我们的组件中 数据渲染到页面 是通过useEffect第一次请求到数据渲染到页面上， 它的第二个依赖项，如果没有传值，就是只渲染一次，如果每次数据更新需要渲染就通过传依赖项。
  
  5. 由于connect后，各connect组件是共享store的，所以各组件可以通过store来进行数据通信。数据变化通过connect的两个函数作为参数mapStateToProps  和 mapDispatchToProps 这两个函数来进行的。
  
     ```
     mapStateToProps  这个函数会接受 store.getState() 的结果作为参数 => state，然后返回一个对象，这个对象是根据 state 生成的。
     
     mapStateTopProps 相当于告知了 Connect 应该如何去 store 里面取数据，然后可以把这个函数的返回结果传给被包装的组件
     
      mapDispatchToProps  和 mapStateToProps 一样，它返回一个对象，这个对象内容会同样被 connect 当作是 props 参数传给被包装的组件。不一样的是，这个函数不是接受 state 作为参数，而是 dispatch，你可以在返回的对象内部定义一些函数，这些函数会用到 dispatch 来触发特定的 action。
     ```
  

###    3. react方面的性能优化有哪些

在 `hooks` 出来之后，函数组件中没有 `shouldComponentUpdate` 生命周期，我们无法通过判断前后状态来决定是否更新。`useEffect` 不再区分 `mount` `update` 两个状态，这意味着函数组件的每一次调用都会执行其内部的所有逻辑，那么会带来较大的性能损耗。所以，`hooks`中学习`memo`来减少重复渲染，实现性能优化。

(1) react循环的的时候加一个key = {id} 保证唯一性
(2) 捕获错误 <ErrorBoundary> 把可能出现的组件包起来

##### 项目里面的react 性能优化

- 多个资源请求合并成一个，减少接口请求。

- Immutable 的数据结构 （gzip压缩算法。雪碧图iconfont）

- base64格式图片。减少http请求，降低服务器的请求消耗

- 防抖和节流

- shouldComponentUpdate

- useMemo 和 useCallback（子组件向父组件通信);

- memo ，pureComponent 

- react 自带  react-lazyload 路由懒加载

-  better-scroll  图片懒加载

- fragment标签 它的作用是性能优化

  React 中的一个常见模式是一个组件返回多个元素。Fragments 可以让你将子列表分组， 所有的子组件都挂载到它上面，它再一次性挂载，而无需向 DOM 添加额外节点。

  ```javascript
  //在所有的组件return 里面所有标签用<fragment />包裹一下
  return (
          <>
              <input 
                  type="text"
                  onChange={(e) => setFilter(e.target.value)}
                  value={filter}/>
              <ul ref={mountedRef}>
                  {
                      userCollection.map((user, index) => (
                      <li key={index}>{user.name}</li>
                  ))}
              </ul>
          </>
      )
  ```

- react 自带  react-lazyload 路由懒加载

  使用`React.lazy`和`Suspense`来实现路由懒加载组件进行优化，可以理解成，先存放不加载就是`lazy` ，需要时即满足渲染条件就开始加载，就是`Suspense `，这样可以快速打开页面。

  React文档对React.lazy的说法：

  > React.lazy必须通过调用动态的`import()`加载一个函数，此时会返回一个`Promise`，并解析(`resolve`)为一个带有包含React组件的默认导出的模块。

  我们使用`Suspense`，它必须是延迟加载组件的父级(**即React.lazy加载的组件只能在<React.Suspense>组件下使用**)

- 利用 better-scroll 监听屏幕滚动事件，然后调用 forceCheck方法。

- 像函数组件的 memo，以及类组件的 PureComponent 和 shouldComponentUpdate 。

  1. memo 为高阶组件，通过记忆组件渲染结果的方式来提高组件的性能表现。
     memo 仅检查 props 变更。如果函数组件被 React.memo 包裹，且其实现中拥有 useState 或 useContext 的 Hook，当 context 发生变化时，它仍会重新渲染。
  2. 默认情况下其只会对复杂对象做浅层对比，如果我们想要控制对比过程，可以将自定义的比较函数通过第二个参数传入来实现。**通过第二个参数指定一个自定义的方法 来判断两次 props 有什么不同，memo会帮我们缓存上一个值，当我们接收一个新的值之后，两个值进行比较，相同的话，拒绝修改，直接使用已经缓存的值，不同的话， 则改变。 达到即缓存又更新的能力。**

  3. pureComponent 是 react 官方将shouldComponentUpdate() 函数封装的好的组件。其中的shouldComponentUpdate() 也仅作对象的浅层比较。如果对象中包含复杂的数据结构，则会产生错误的比对结果。

  4. 如果我们要优化的话，可以使用 Immutable 数据结构。

     使用 Immutable 原理(持久化数据结构)遵循结构共享，数据不可变。一旦创建，就不能更改的数据

  5. 需要注意的是：
     shouldComponentUpdate  返回 false 组件就不会重新渲染， 返回 true 才会重新渲染
     memo 返回 true 不会重新渲染，返回 false 才会重新渲染，因为 他是将上一次的props与这次的props作比较 相同返回 true 不同返回 false。

  

- useMemo useCallback

  1. usememo 是让函数在依赖不改变的情况下，不对这个值进行重新计算。
  2. usecallback 是对函数进行缓存，用于子组件引用父组件的函数，父组件重新渲染，避免函数的引用发生改变。

  1. useMemo优化的是函数进行运算的开销
  2. useCallback优化的是组件重新渲染的开销

- styled-components
  优点:更加灵活，让react更加组件化，html css js 的内聚性。
  
  方便复用，类名不冲突
  因为使用模板字符串，我们也可以进行传参，使用js 控制样式。
  
  可以获取js里面的变量，比如设置主题色。
  
- SSR 服务器渲染，用于解决首屏白屏时间过长的问题，
  简单来说就是 让服务器先将(react / vue)页面解析成 html 字符串
  (我记得是有一个 renderToString 方法 可以将 react组件 渲染成html字符串 )，然后在发送给浏览器。react服务端只能渲染到componentDidmount阶段，交互事件服务端不能实现，需要在客户端同构组件。
  
  但是这样会导致js的事件绑定出现问题，我们需要用到同构思想。
  让js 文件在客户端再跑一次，使用 ReactDom的 hydrate （调和）方法，
  告诉客户端不需要构造dom节点了，只需要完成事件绑定。
  很遗憾我的项目还没有实现这一步功能，我会继续完善的。

### 项目学到的知识点：

​		1.项目规范，项目文件夹划分的规范，变量名小驼峰，组件名大驼峰，常量大写
​		2.写组件，整个项目都采用了函数式组件，并且全面HOOKS
​		3.为了组件的不必要渲染，做了memo的包裹（浅层比较）;
​		4.组件内部状态使用的是useState，useReducer，业务数据都放在redux管理，每个页面都有自己对应的reducer，然后把多个reducer进行合并共享在index.js里面
​		5.学到了styled-components书写样式，非常方便，嵌套，传参，表达式
​		6.学到了axios的封装，请求相关数据
​		7.学到了antd相关使用，轮播图
​		8.复用性组件的封装