### 1.  为什么选择使用框架而不是原生？(为什么选择react)

```
优点：
	1. 组件化: 其中以 React 的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。
	2. 天然分层: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。
	3. 生态: 现在主流前端框架都自带生态,不管是数据流管理架构还是 UI 库都有成熟的解决方案。
	4. 开发效率: 现代前端框架都默认自动更新DOM,而非我们手动操作,解放了开发者的手动DOM成本,提高开发效率,从根本上解决了UI 与状态同步问题.
```

我选择react是 因为 ：

jsx写起来舒服、虚拟Dom的优点，diff 渲染，性能高效、useSate数据不可变 返回新的数据、react可以用redux 数据流更好管理、组件化思想

### 2. React Hooks 与 class 组件相比，有什么优点？(为什么要用hooks)

```
Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。现在很多大厂都已经全面升级react hooks 能熟练运用hooks 会成为你的加分项 
1. class 组件在组件之间复用状态逻辑很难,而 Hook 使你在无需修改组件结构的情况下复用状态逻辑。
2. class 组件的复杂组件变得难以理解。
3. class 难以理解，Hook 使你在非 class 的情况下可以使用更多的 React 特性。 
4. 极大地减少了代码量。
```

我选择用hooks是因为：使用ReactHooks无需复杂的DOM结构。

我们都知道React的核心思想就是，将一个页面拆分成一堆独立的，可以复用的组件，并且用自上而下的单向数据流的形式将这些组件串联起来。但如果在大型的项目中使用React，那么我们就会发现项目中实际上很多React组件冗长且难以复用。尤其是那些写成class的组件，他们本身本来就包含了状态（state），所以复用这类组件就变得很麻烦。

### 3. react  class组件的生命周期

![img](https://upload-images.jianshu.io/upload_images/9014816-37edd5c87c5bf503.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

```markdown
目前 react 的生命周期分为三个阶段，分别是 挂载阶段、更新阶段、卸载阶段
- 挂载阶段(初始化渲染)
  1. constructor ：构造函数，最先被执行，通过给 this.state 赋值对象来初始化内部 state
  2. render( )：这个方法必须返回一个JSX元素，用来重新渲染组件。render() 函数应该为纯函数，这意味着在不修改组件 state 的情况下，每次调用时都返回相同的结果，render( )不直接与浏览器交互。
  3. componentDidMount ：在组件挂载后(插入DOM树)立即调用，此时可以操作 Dom 请求数据
- 更新阶段
  1.shouldComponentUpdate 通常来优化 react 性能，判断组件是否需要渲染
  2. render( )
  3. componentDidUpdate 页面更新后立即调用
- 卸载阶段
  1. componentWillUnmount 组件销毁或卸载时调用，可以用来清除定时器，取消网络请求等操作。
被废弃的： componentWillMount componentWillUpdate
```

### 4. component 和 pureComponent 的区别，使用时有什么要注意的地方。

```
	React.PureComponent 与 React.Component很相似。两者区别在于：purecomponent 通过state和props的浅比较 来实现shouldCompoentUpdata()组件是否要更新。Component不会比较当前和下个状态的props和state，并未实现 shouldComponentUpdate()。
	如果赋予 React 组件相同的 props 和 state，render() 函数会渲染相同的内容，那么在某些情况下使用 React.PureComponent 可提高性能。
```

```
	React.PureComponent 中的 shouldComponentUpdate() 仅作对象的浅层比较。如果对象中包含复杂的数据结构，则有可能因为无法检查深层的差别，产生错误的比对结果。仅在你的 props 和 state 较为简单时，才使用 React.PureComponent，或者在深层数据结构发生变化时调用 forceUpdate() 来确保组件被正确地更新。你也可以考虑使用 immutable 对象加速嵌套数据的比较。
	此外，React.PureComponent 中的 shouldComponentUpdate() 将跳过所有子组件树的 prop 更新。因此，请确保所有子组件也都是“纯”的组件。
```

### 5. React.memo 与 pureComponent 的区别

```
	memo 为高阶组件，通过记忆组件渲染结果的方式来提高组件的性能表现。
	memo 仅检查 props 变更。如果函数组件被 React.memo 包裹，且其实现中拥有 useState 或 useContext 的 Hook，当 context 发生变化时，它仍会重新渲染。
	React.memo（只能用在 function component 上）默认对 props 浅比较。如果我们想要控制对比过程，可以将自定义的比较函数通过第二个参数传入来实现。通过第二个参数指定一个自定义的方法 来判断两次 props 有什么不同，memo会帮我们缓存上一个值，当我们接收一个新的值之后，两个值进行比较，相同的话，拒绝修改，直接使用已经缓存的值，不同的话， 则改变。
	
	pureComponent 是 react 官方将shouldComponentUpdate() 函数封装的好的组件。其中的shouldComponentUpdate() 也仅作对象的浅层比较。如果对象中包含复杂的数据结构，则会产生错误的比对结果。如果我们要优化的话，可以使用 Immutable 数据结构。
需要注意的是：
shouldComponentUpdate  返回 false 组件就不会重新渲染， 默认返回 true 才会重新渲染
memo 返回 true 不会重新渲染，返回 false 才会重新渲染，因为 他是将上一次的props与这次的props作比较 相同返回 true 不同返回 false。
```

### 6.useMemo 和 useCallBack 的区别

```markdown
同：useMemo 和 useCallback 都接收两个参数,第一个参数为回调，第二个参数为要依赖的数据
	有共同作用：都有缓存的作用，仅仅 依赖数据 发生变化, 才会重新计算结果
异：
1. usememo 用来缓存值(计算结果的值)，当 组件内部某一个渲染的数据，需要通过计算而来，这个计算是依赖与特定的state、props数据，我们就用useMemo来缓存这个数据，让函数在依赖不改变的情况下，不对这个值进行重新计算。
2. usecallback 是对一个函数进行缓存，用于子组件引用父组件的函数，父组件重新渲染，子组件不会因为这个函数的变动重新渲染。和React.memo搭配使用
举例：
父组件中input值发生变化时，会导致Child重新render，使用React.memo可以可以解决。
但是当Child组件接收父组件中的onSubmit函数，React.memo就不能解决，
	const Child = React.memo(({ onSubmit }) => {
    	console.log("child") //input变化时就打印
    	return (
       	 	<div>
           		<button onClick={onSubmit}>submit</button>
        	</div>
    	)
	})
因为input变化后，生成了新的onSubmit,React.memo认为是不同的onSubmiit，所以更新了
这时候，就要用到useCallback了
  	const onSubmit = React.useCallback(() => {
        console.log(text)
    }, [text]) //text是新的，text变化时，生成了新的onSubmit,表示text更新时执行
```

### 7. React.lazy 和 React.Suspense

```javascript
React.lazy() 允许你定义一个动态加载的组件。这有助于缩减 bundle 的体积，并延迟加载在初次渲染时未用到的组件。

// 这个组件是动态加载的
const SomeComponent = React.lazy(() => import('./SomeComponent'));

渲染 lazy 组件依赖该组件渲染树上层的 <React.Suspense> 组件。这是指定加载指示器（loading indicator）的方式。
```

```javascript
React.Suspense 可以指定加载指示器（loading indicator），以防其组件树中的某些子组件尚未具备渲染条件。目前，懒加载组件是 <React.Suspense> 支持的唯一用例：

// 该组件是动态加载的
const OtherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    // 显示 <Spinner> 组件直至 OtherComponent 加载完成
    <React.Suspense fallback={<Spinner />}>
      <div>
        <OtherComponent />
      </div>
    </React.Suspense>
  );
}
```

### 8. setState 到底是异步还是同步？

> 大部分情况下，setState是异步的，如初始化了state= {a : 1}  this.setState{a : 2},此时的this.state.a=1,不会改变，就是不会拿到最新的结果 。要改变的话，用第二个参数，回调函数 this.setState( {a : 2},() => )
>
> 有时候是同步的，如 setTimeout 

1. setState只在**合成事件和钩子函数(生命周期)**中是**异步**的，在**原生事件(addEventListener)和 setTimeout **中都是**同步**的。
2. setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中**没法立马拿到更新后的值**，形成了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。
3. setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新（isBatchingUpdate 是不是批量更新），在“异步”中如果对同一个值进行多次setState，setState的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，在更新时会对其进行合并批量更新。

### 9.  使用 styled-components的优点

```
更加灵活，让react更加组件化，增强了 html css js 的内聚性。方便复用，类名不冲突
由于使用模板字符串，我们也可以进行传参，使用js 来控制样式。
```

### 11. shouldComponentUpdate 中进行深层比对 （递归比对）

shouldComponentUpdate 是我们进行性能优化的利器，我们之后的优化方案都会基于它来进行。

 pureComponent 是 react 官方将shouldComponentUpdate() 函数封装的好的组件。其中的shouldComponentUpdate() 也仅作对象的浅层比较。如果对象中包含复杂的数据结构，则会产生错误的比对结果。

优化方案一：PureComponent (memo) 进行浅层比较

优化方案二:shouldComponentUpdate 中进行深层比对

优化方案 3: immutable 数据结构 + SCU (memo) 浅层比对

```
浅层比对 ，props 中所有的属性和值进行递归比对。前四个是PureComponent 浅层比较的源码分析
    1. 保证两者都是基本数据类型。基础数据类型直接比较出结果
    2. 只要有一个不是对象数据类型就返回 false
    3. 在这里已经可以保证两个都是对象数据类型，比较两者的属性数量		
    4. 比较两者的属性是否相等，值是否相等
    
    当访问到对象的属性值的时候，将属性值再进行递归比对，这样就达到了深层比对的效果。但是想想一种极端的情况，就是在属性有一万条的时候，只有最后一个属性发生了变化，那我们就不得已将一万条属性都遍历。这是非常浪费性能的。
```

### 12. 什么是 immutable 数据？它有什么优势？

![img](https://user-gold-cdn.xitu.io/2019/10/20/16de7a154c8b30b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

```markdown
immutable 数据一种利用结构共享形成的持久化数据结构，一旦有部分被修改，那么将会返回一个全新的对象，并且原来相同的节点会直接共享。

具体点来说，immutable 对象数据内部采用是多叉树的结构，凡是有节点被改变，那么它和与它相关的所有上级节点都更新。

它只更新了父节点，比直接比对所有的属性简直强太多，并且更新后返回了一个全新的引用，即使是浅比对也知道数据的改变。
因此，采用 immutable 既能够最大效率地更新数据结构，又能够和现有的 PureComponent (memo) 顺利对接，能够获取到状态的变化，是提高 React 渲染性能的极佳方案。

immutable 也有一些被部分开发者吐槽的点，首先是 immutable 对象和 JS 对象要注意转换，不能混用，这个大家注意适当的时候调用 toJS 或者 fromJS 即可，问题并不大。
	1. fromJS 它的功能是将 JS 对象转换为 immutable 对象。
		import {fromJS} from 'immutable';
			export const changeIntro = (data) => ({
   			type: actionTypes.CHANGE_INTRO,
    		// data:data
    		data:fromJS(data)
		})
		
		const defaultState = fromJS({
             // 简介
            intro: [],
            brief: [],
            articleList: [],
            // 目录列表
            chapterList: [],
            // 推荐列表
            recommendList: [],
		})
	2. toJS
	const jsObj = immutableState.toJS ();
	 intro.toJS().map((m, i) => {}
其次就是对于 immutable API 的学习成本的争议。我觉得这个问题见仁见智吧，我的观点是：如果你目前沉溺在已经运用得非常熟练的技术栈当中，不说深入学习新技术，连新的 API 都懒得学，我觉得对个人成长来说是一个不太好的征兆。

而且，项目中涉及的 api 并没有那么复杂，完全没必要从头到尾把 immutable.js 的 Api 全都记住。接下来我们就来悉数一下项目将要用到的 immutable 的功能。

优点：
1. Immutable 降低了 Mutable 带来的复杂度
2. 结构共享 节省内存
3. Undo/Redo，Copy/Paste，甚至时间旅行这些功能做起来小菜一碟
4. 拥抱函数式编程 Immutable 本身就是函数式编程中的概念，纯函数式编程比面向对象更适用于前端开发。
```

##### 详细介绍 Immutable 数据，它和 mutable 数据有什么区别？

 Mutable：可变，在 JavaScript 中，对象是引用类型的数据，其优点在于频繁的修改对象时都是在**原对象的基础上修改**，并不需要重新创建，这样可以有效的利用内存，不会造成内存空间的浪费。但是它也有缺点，对于一个复杂结构的对象来说，一不小心就在某个不经意间**修改了数据**，假如该对象又在多个作用域中用到，此时很难预见到数据**是否改变**以及何时改变的。

常规的解决办法可以通过将对象进行**深拷贝**的形式复制出一个新的对象，再在新对象上做修改的操作，这样能确保数据的可控性，但是频繁的复制会造成**内存空间**的大量浪费。

为了能更好的解决上述的问题，出现了 Immutable 对象，Immutable 从字面上翻译成中文是「不可变」。每次修改一个 Immutable 对象时都会创建一个新的**不可变的对象**，在新对象上操作并**不会影响到原对象**的数据。

普通的 Mutable 对象的深拷贝操作会将一整份数据都复制一遍，而 Immutable 对象在修改数据时并不会复制一整份数据，而是将变化的节点与未变化的节点的父子关系转移到一个新节点上，类似于链表的结构。