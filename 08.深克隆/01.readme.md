## 浅拷贝和深拷贝的区别

一、浅拷贝和深拷贝

- 深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。

![图片描述](https://segmentfault.com/img/bVbrl56?w=310&h=227)

- 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。

- 但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。

二、赋值和浅拷贝的区别

赋值：给对象赋值给新变量时，赋给对象在栈中的位置，而不是堆中的位置。指向同一个存储空间，无论哪个对象发生改变，都会改变存储空间的内容。

浅拷贝：按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。

如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。

## 浅克隆

    浅克隆之所以被称为浅克隆，是因为对象只会被克隆最外部的一层,
    至于更深层的对象,则依然是通过引用指向同一块堆内存.

## 深克隆
- 简单版
    JSON.parse方法可以将JSON字符串反序列化成JS对象，
    stringify方法可以将JS对象序列化成JSON字符串,
    这两个方法结合起来就能产生一个便捷的深克隆.
```js
    const newObj = JSON.parse(JSON.stringify(oldObj));
```
- 局限性：
1. 他无法实现对函数 、RegExp等特殊对象的克隆
2. 会抛弃对象的constructor,所有的构造函数会指向Object
3. 对象有循环引用,会报错

- 面试版深克隆
由于要面对不同的对象(正则、数组、Date等)要采用不同的处理方式，我们需要实现一个对象类型判断函数。

- 局限性:
1. 一些特殊情况没有处理: 例如Buffer对象、Promise、Set、Map
2. 另外对于确保没有循环引用的对象，我们可以省去对循环引用的特殊处理，因为这很消耗时间

- 实现一个深克隆函数
1. 判断对象类型的函数  isType
    面对不同的对象(正则、数组、Date等)要采用不同的处理方式
2. 提取flags的函数  getRegExp 处理正则表达式
3. 实现深克隆
思路：
1. 递归
2. 判断类型
3. 检查环(也叫循环引用)
4. 需要忽略原型

    - 判断类型
    - 处理正则
    - 维护两个储存循环引用的数组
        - 对数组做特殊处理
        - 对正则对象做特殊处理
        - 对Date对象做特殊处理
        - 处理对象原型
        - 处理循环引用