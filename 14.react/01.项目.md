###  你在写项目遇到什么难点

- **页面交互**：	
  
  1. 账户页面
  
  首页在页面埋下一个id值。通过回调函数handleClick  点击获取id 改变背景色，同时用useState设置保存原来的state的值，当点击下一个，改变背景色，同时，还原上一个state的背景色，实现每次点击都改变背景色的效果。
  
  2. 支付台
  
  怎么判断余额是否充足的问题。用useState初始化状态为false，if 判断 为setnotEnough或setpaySuccess

- **redux的设计** 

  store  redux做数据流管理

  redux是为了解决react组件间通信和组件间状态共享而提出的一种解决方案

![img](https://pics0.baidu.com/feed/bd3eb13533fa828b575e7ddca365cd30970a5a0b.jpeg?token=78242bf3a90828d6c53cda4e82111a28&s=0881C7167DCDC90D1E50A9CB020030F1)

由于connect后，各connect组件是共享store的，所以各组件可以通过store来进行数据通信

##### Redux有3大核心概念：

1. Store：存储state的对象，store改变，页面状态也改变

   Store则是我们储存state的地方。

   我们通过redux当中的createStore方法来创建一个store

2. Action：接收state改变的状态，当前组件调用相关的action方法。

   Action表示应用中的各类动作或操作，

   不同的操作会改变应用相应的state状态，

   说白了就是一个带type属性的对象。

3. Reducer：修改store中state的值，返回一个新的state的值。

   纯函数: 一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用

   它和 Array.prototype.reduce 当中传入的回调函数非常相似

   reducer接受state和action并返回新的state

   流程：
   
   首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State
   State一旦有变化，Store就会调用监听函数，来更新View。

###    react方面的性能优化有哪些

学到的知识点：
		1.项目规范，项目文件夹划分的规范，变量名小驼峰，组件名大驼峰，常量大写
		2.写组件，整个项目都采用了函数式组件，并且全面HOOKS
		3.为了组件的不必要渲染，做了memo的包裹（浅层比较）;
		4.组件内部状态使用的是useState，useReducer，业务数据都放在redux管理，每个页面都有自己对应的reducer，然后把多个reducer进行合并共享在index.js里面
		5.学到了styled-components书写样式，非常方便，嵌套，传参，表达式
		6.学到了axios的封装，请求相关数据
		7.学到了antd相关使用，轮播图
		8.复用性组件的封装。

在学习`react`中，性能优化的点主要在于：

(1)调用 `setState`，就会触发组件的重新渲染，无论前后 `state` 是否相同，

(2)父组件更新，子组件也会自动更新。

在 `hooks` 出来之后，函数组件中没有 `shouldComponentUpdate` 生命周期，我们无法通过判断前后状态来决定是否更新。`useEffect` 不再区分 `mount` `update` 两个状态，这意味着函数组件的每一次调用都会执行其内部的所有逻辑，那么会带来较大的性能损耗。所以，`hooks`中学习`memo`来减少重复渲染，实现性能优化

##### react 性能优化

- react 自带  react-lazyload 路由懒加载

  使用`React.lazy`和`Suspense`来实现路由懒加载组件进行优化，可以理解成，先存放不加载就是`lazy` ，需要时即满足渲染条件就开始加载，就是`Suspense `，这样可以快速打开页面。

  React文档对React.lazy的说法：

  > React.lazy必须通过调用动态的`import()`加载一个函数，此时会返回一个`Promise`，并解析(`resolve`)为一个带有包含React组件的默认导出的模块。

  我们使用`Suspense`，它必须是延迟加载组件的父级(**即React.lazy加载的组件只能在<React.Suspense>组件下使用**)

- 使用 react-lazyload 的包，利用 better-scroll 监听屏幕滚动事件，然后调用 forceCheck方法。

- 使用 Immutable 原理(持久化数据结构)遵循结构共享，数据不可变。一旦创建，就不能更改的数据

- 像函数组件的 memo，以及类组件的 PureComponent 和 shouldComponentUpdate 。

  shouldComponentUpdate 返回 false 组件就不会重新渲染， 返回 true 才会重新渲染。

  其实 PureComponent 就是 react 官方封装了 shouldComponentUpdate 。purecomponent 通过state和props的浅比较 来实现shouldCompoentUpdata()组件是否要更新。
  它们都是为了减少不必要的渲染来做优化的 但这两个只适合浅层比较，如果更深层次的比较是没有作用的。如果想比较，我们应该使用 Immutable 数据结构(数据共享)和React.memo

- memo提供了自定义比较。如果我们想控制对比过程，我们可以通过传入第二个参数来实现。**通过第二个参数指定一个自定义的方法 来判断两次 props 有什么不同，memo会帮我们缓存上一个值，当我们接收一个新的值之后，两个值进行比较，相同的话，拒绝修改，直接使用已经缓存的值，不同的话， 则改变。 达到即缓存又更新的能力。**

  

- useMemo useCallback

  SSR 服务器渲染，用于解决首屏白屏时间过长的问题，
  简单来说就是 让服务器先将(react / vue)页面解析成 html 字符串
  (我记得是有一个 renderToString 方法 可以将 react组件 渲染成html字符串 )，然后在发送给浏览器。
  但是这样会导致js的事件绑定出现问题，我们需要用到同构思想。
  让js 文件在客户端再跑一次，使用 ReactDom的 hydrate （调和）方法，
  告诉客户端不需要构造dom节点了，只需要完成事件绑定。
  很遗憾我的项目还没有实现这一步功能，我会继续完善的。

- styled-components
  优点:更加灵活，让react更加组件化，html css js 的内聚性。方便复用，类名不冲突
  由于使用模板字符串，我们也可以进行传参，使用js 控制样式。