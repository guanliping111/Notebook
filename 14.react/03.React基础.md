- ### 1. React Hooks 与 class 组件相比，有什么优点？为什么流行？
  
  ```
  Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。
  1. class 组件在组件之间复用状态逻辑很难,而 Hook 使你在无需修改组件结构的情况下复用状态逻辑。
  2. class 组件的复杂组件变得难以理解。
  3. class 难以理解，Hook 使你在非 class 的情况下可以使用更多的 React 特性。 
  4. 极大地减少了代码量。
  ```
  
  ### 2. 性能优化
  
  ### 3. useMemo 和 useCallBack 的区别
  
  ```
  1. usememo 是让函数在依赖不改变的情况下，不对这个值进行重新计算。
  2. usecallback 是对函数进行缓存，用于子组件引用父组件的函数，父组件重新渲染，避免函数的引用发生改变。
  
  1. useMemo优化的是函数进行运算的开销
  2. useCallback优化的是组件重新渲染的开销
  ```
  
  ### 4. 虚拟DOM
  
  ```
  真实页面对应一个 DOM 树。在传统页面的开发模式中，每次需要更新页面时，都需要手动操作DOM来进行更新，而我们知道 DOM 操作性能消耗很大。于是在 React 中出现了虚拟 DOM，它把真实 DOM 树转换为 JavaScript 对象树。
  
  当每次数据更新时，它会重新计算虚拟 dom 树，并和上一次生成的dom 树作对比，使用 diff 算法找出不同的部分，再将这些应用到真实的dom 上。
  ```
  
  ### 5. 为什么选择使用框架而不是原生？
  
  ```
  优点：
  	1. 组件化: 其中以 React 的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。
  	2. 天然分层: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。
  	3. 生态: 现在主流前端框架都自带生态,不管是数据流管理架构还是 UI 库都有成熟的解决方案。
  	4. 开发效率: 现代前端框架都默认自动更新DOM,而非我们手动操作,解放了开发者的手动DOM成本,提高开发效率,从根本上解决了UI 与状态同步问题.
  ```
  
  ### 6. component 和 pureComponent 的区别，使用时有什么要注意的地方。
  
  ```
  React.PureComponent 与 React.Component很相似。两者的区别在于React.Component并未实现 shouldComponentUpdate()，而 React.PureComponent 中以浅层对比 prop 和 state 的方式来实现了该函数。
  
  如果赋予 React 组件相同的 props 和 state，render() 函数会渲染相同的内容，那么在某些情况下使用 React.PureComponent 可提高性能。
  ```
  
  ```
  React.PureComponent 中的 shouldComponentUpdate() 仅作对象的浅层比较。如果对象中包含复杂的数据结构，则有可能因为无法检查深层的差别，产生错误的比对结果。仅在你的 props 和 state 较为简单时，才使用 React.PureComponent，或者在深层数据结构发生变化时调用 forceUpdate() 来确保组件被正确地更新。你也可以考虑使用 immutable 对象加速嵌套数据的比较。
  
  此外，React.PureComponent 中的 shouldComponentUpdate() 将跳过所有子组件树的 prop 更新。因此，请确保所有子组件也都是“纯”的组件。
  ```
  
  ### 7. Memo 与 pureComponent 的区别
  
  ```
  memo 为高阶组件，通过记忆组件渲染结果的方式来提高组件的性能表现。
  memo 仅检查 props 变更。如果函数组件被 React.memo 包裹，且其实现中拥有 useState 或 useContext 的 Hook，当 context 发生变化时，它仍会重新渲染。
  默认情况下其只会对复杂对象做浅层对比，如果我们想要控制对比过程，可以将自定义的比较函数通过第二个参数传入来实现。
  ```
  
  ### 8. React.lazy 和 React.Suspense
  
  ```
  React.lazy() 允许你定义一个动态加载的组件。这有助于缩减 bundle 的体积，并延迟加载在初次渲染时未用到的组件。
  
  // 这个组件是动态加载的
  const SomeComponent = React.lazy(() => import('./SomeComponent'));
  
  渲染 lazy 组件依赖该组件渲染树上层的 <React.Suspense> 组件。这是指定加载指示器（loading indicator）的方式。
  ```
  
  ```javascript
  React.Suspense 可以指定加载指示器（loading indicator），以防其组件树中的某些子组件尚未具备渲染条件。目前，懒加载组件是 <React.Suspense> 支持的唯一用例：
  
  // 该组件是动态加载的
  const OtherComponent = React.lazy(() => import('./OtherComponent'));
  
  function MyComponent() {
    return (
      // 显示 <Spinner> 组件直至 OtherComponent 加载完成
      <React.Suspense fallback={<Spinner />}>
        <div>
          <OtherComponent />
        </div>
      </React.Suspense>
    );
  }
  ```
  
  ### 9. setState 到底是异步还是同步？
  
  ```
  1. setState只在合成事件和钩子函数(生命周期)中是“异步”的，在原生事件(addEventListener)和setTimeout 中都是同步的。
  2. setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。
  3. setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，在更新时会对其进行合并批量更新。
  ```
  
  ### 10. redux 基本流程
  
  ```
  Store：保存数据的地方，可以把它看成一个容器。
  State：Store对象包含所有数据，某个时间点的数据集合就叫做State。
  Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应该要发生变化了。
  Action Creator：一个函数用来生成Action的。
  Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参数，返回一个新的State。
  dispatch：是View发出Action的唯一方法。
  
  然后我们过下整个工作流程：
  
  首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
  然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State
  State一旦有变化，Store就会调用监听函数，来更新View。
  ```
  
  ### 11. 怎么用 redux-thunk 解决异步问题
  
  ```
  纯粹使用redux时，你需要dispatch的是一个action对象，当你使用redux-thunk后，你dispatch的是一个function，redux-thunk中间件会自动调用这个function，并且传递dispatch方法作为其第一个参数，于是我们就能在这个function内根据我们的请求状态：开始，请求中，请求成功／失败，dispatch我们期望的任何action了，这也是为什么它能支持异步dispatch action 的原因。
  ```
  
  ### 12. Hooks 的实现原理
  
  ```
  hooks 是通过一个总的数组或者链表来维护的，他将每个hooks函数放到数组里面，当我们声明hooks函数时，它都会依次按照顺序存起来，当我们调用相关的函数时，它也会按照顺序执行。所以以相同的顺序调用就是他的实现原理。这也是他不能放在 if的逻辑判断和循环语句之中的原因。
  ```
  
  ### 13. Link引入的css和import引入的css有啥区别
  
  ```
  1、link引入的Css可以同时加载，@import引入的Css是在页面加载完毕后再加载
  2、link是html标签，没有兼容性问题，而@import是css2之后引入的，存在一定的兼容性问题，但是目前来看，由于基本都是CSS2-Css3了，因此使用上没有啥兼容性问题了
  3、JS可以通过DOM操作link标签，但是无法操作@import
  4、当然一般建议优先使用link，减少使用@import
  ```