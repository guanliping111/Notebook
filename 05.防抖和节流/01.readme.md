## 防抖

- 函数防抖：将几次操作合并为一次操作进行。
  原理是: 维护一个计时器，规定在 wait 时间后触发函数，
  但是在wait时间内再次触发的话，就会取消之前的计时器而重新设置。
   这样一来，只有最后一次操作能被触发。

```javascript
	//实现防抖 步骤
    //1.let timeout
    //2. if(timeout)  clear
    //3. timeout = setTime
    function debounce(fn, wait) {
        let timeout = null;
        //写一个具有防抖功能的自己内部定义的函数function
        return function(event) {
            if(timeout) clearTimeout(timeout);
            timeout = setTimeout(() => {
                fn.call(this,event);
            },wait)
        }
    }
```



## 节流
两种实现方式
1. 时间戳
    当触发事件的时候，我们取出当前的时间戳，
    然后减去之前的时间戳(最一开始值设为 0 )，
    如果大于设置的时间周期，就执行函数，
    然后更新时间戳为当前的时间戳，如果小于，就不执行。
2. 定时器
    当触发事件的时候，我们设置一个定时器，再触发事件的时候，
    如果定时器存在，就不执行，直到定时器执行，
    然后执行函数，清空定时器，这样就可以设置下个定时器。
3. 双剑合璧
    一个有头有尾的 就是鼠标移入能立刻执行，停止触发的时候还能再执行一次！

```javascript
<script>
    //函数节流：使得一定时间内只触发一次函数。
    //原理是: 通过判断是否到达一定时间来触发函数。
    //函数节流主要有两种实现方法：时间戳和定时器
    //以下是两种结合
    function throttle(func, wait){
        var previous = 0;
        var timeout = null;
        return function(event) {
            var now = new Date().getTime();
           let remain = wait - (now - previous);
           //时间戳
           if(now - previous > wait) {
                func(); //执行函数
                previous = now; //更新时间戳
            }
            //定时器
            else if(!timeout){
                timeout = setTimeout(() => {
                    func(); //执行函数
                    timeout = null;//清空定时器
                    previous = new.Date().getTime(); //更新previous
                },remain)
           }
        }
    }
</script>
```

