### 一、事件冒泡与事件捕获

出现原因：

```html
<div id="outer">
    <p id="inner">Click me!</p>
</div>

上面的代码当中一个div元素当中有一个p子元素，如果两个元素都有一个click的处理函数，那么我们怎么才能知道哪一个函数会首先被触发呢？
```

事件冒泡和事件捕获分别由微软和网景公司提出，这两个概念都是为了解决页面中**事件流**（事件发生顺序）的问题

- 事件冒泡：事件会从最内层的元素开始发生，一直向上传播，直到document对象。

  

- 事件捕获：与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。

![img](https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=2269261448,2123572753&fm=26&gp=0.jpg)

捕获阶段：window----> document----> html----> body ---->目标元素

冒泡阶段：当前元素---->body ----> html---->document ---->window

### 二、addEventListener 的第三个参数

"DOM2级事件”中规定的事件流同时支持了事件捕获阶段和事件冒泡阶段，而作为开发者，我们可以选择**事件处理函数在哪一个阶段被调用**。

addEventListener方法用来为一个特定的元素绑定一个事件处理函数，是JavaScript中的常用方法。addEventListener有三个参数： element.addEventListener(event, **function**, useCapture)

### 三、事件代理

**事件委托** 本质上是利用浏览器 事件**冒泡**的机制，事件在在冒泡过程中会上传到**父节点**，父节点可通过事件对象获取到 **目标节点**，=>  把**子节点的监听事件定义在父节点上**，**由父节点的监听事件统一处理多个子元素的事件 **=>  称为 事件代理。

使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的**动态绑定**，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给**父元素中的监听事件**来处理。

对于事件代理来说，在事件捕获或者事件冒泡阶段处理并没有明显的优劣之分，但是由于事件冒泡的事件流模型被所有主流的浏览器兼容，从兼容性角度来说还是建议大家使用事件冒泡模型。

### 四、阻止冒泡

1. 给子级加 event.stopPropagation( )

2. 在事件处理函数中返回 false

   但是这两种方式是有区别的。`return false` 不仅阻止了事件往上冒泡，而且阻止了事件本身(默认事件)。`event.stopPropagation()`则只阻止事件往上冒泡，不阻止事件本身。

3. event.target==event.currentTarget，让触发事件的元素等于绑定事件的元素，也可以阻止事件冒泡

#### 补充：阻止默认事件

（1）event.preventDefault( )

（2）return false

### 五、如何对多个事件进行处理？

-  有一万个 li 节点 给这些节点绑上事件？ 事件代理

~~~markdown
事件代理：冒泡 捕获
    利用冒泡特点 只有一个事件绑定 监听未来的元素 节点多采取
    父节点可以监听 子节点的点击事件 （子节点点击 父节点也会收到这个click 事件）
    ```html
    <ul>
        <li>111</li>
        <li>222</li>
        <li>333</li>css
        <!-- 3s 之后在下面插入 一个li -->
    </ul>
    ```
~~~

- 全局事件（定时器） 一定要清理