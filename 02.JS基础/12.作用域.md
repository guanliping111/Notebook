## 作用域是什么

- 作用域是一套规则，用于确定在哪里有变量以及如何查找变量。
- 作用域收集并且维护由所有声明的标识符组成的查询，有自己非常严格的规则确定当前执行代码对标识符的访问权限。
- JavaScript 是一门编译语言，在执行代码前的编译中，编译器需要和作用域沟通是否存在某个变量来决定创建还是忽略。
- 接着引擎需要为变量赋值，它会通过 `LHS查询` 或者 `RHS查询` 查找变量，在当前作用域找不到时还要沿着作用域链一直往上往上找，如果在最外层的全局作用域也找不到，那么抛出叫做 ReferenceError 的异常
- 这里如果是使用 `LHS查询` 当全局作用域也不存在查找的变量时会自动创建并返还给引擎。

- react mvvm state setState 状态机制
  变量 程序的状态 声明空间 (闭包 作用域 变量查找 变量提升) 存储值  值修改
  
- 赋值过程  解析/语法分析
  var a = 1; 
  它是怎么运行的  声明 => 询问作用域 => 查找赋值
  var 关键字 
  a  Identifier 标识符 
  = 运算符  
  2 value 
  1. 高级语言
  

## 编译原理
  语言执行的底层
  操作系统 ->  编译原理
  引擎 v8 编译器 解释器
  1. 分词/词法分析 阶段
    [var, a, =, 2]
    token分词  语法错误
    最后成为二进制文件
  2. 解析/语法分析 阶段
    抽象语法树 (AST)
    数据结构 + 算法
    编译器也是一段代码
    HTML <div></div> DOM树
    AST （Abstract Syntax Tree)
  3. 代码生成
    JS 运行时编译
    Java C++ 预编译
    编译器 Compiler
    解释器 Interpreter
    JIT 即时编译器

 var a = 1;
 事实上编译器会进行如下处理。
  1. 遇到 var a，**编译器会询问作用域**是否已经有一个该名称的变量存在于同一个作用域的
    集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作
    用域的集合中**声明**一个新的变量，并命名为 a。
  2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值
    操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的
    变量。如果是，引擎就H会使用这个变量；如果否，引擎会继续**查找**该变量


## 作用域链
```javascript
执行上下文
函数是一等对象
每个函数执行时 会先在自己创建的 AO对象上找对应的属性值
AO 函数的管理
若找不到则往父函数AO上找 -> 找不到 再上一层的AO -> 直到 window(全局作用域)
**AO链 就是JavaScript 中的作用域链**

AO上如果有与函数同名的属性，则会被此函数覆盖
```

  1. 内层作用域在寻找变量的时候未找到，会沿着作用域上的AO向上寻找，直到全局。
  2. AO成链就是作用域链。

    编译阶段 AO生成
    比喻于 prototype 原型链

## 作用域链 AO对象

对于js来说，首先会有一个预编译期的过程，那么在家个预编译期中会发生什么？
预编译：有函数预编译AO，全局预编译GO
预编译是发生在函数执行的前一刻。

```js
    function foo(a,b) {
        console.log(a);// [Function: a]
        var c = 20;
        console.log(c); //20
        function a() { } // 函数声明 
        console.log(a); //[Function: a]
        var b = function c(){};//函数表达式
        console.log(b); // [Function: c]
    }
foo(2,3);
```

(函数)预编译分四个步骤：

1. 创建一个AO对象（activation object）,AO{}
2. 将函数内所有的形参和变量声明 储存到AO对象中，value为undifined
   AO{
    a:undefined,
    b:undefined,
    c:undefined
   }
3. 将形参和实参进行统一。
   AO{
    a:2,
    b:3,
    c:undefined
   }
4. 将所有的函数声明的函数名作为AO对象中的key,函数整体内容为value储存到AO对象中
   AO{
    a:function a(){},
    b:3,
    c:undefined
   }
   最后执行函数的结果为：
    [Function: a]
    20
    [Function: a]
    [Function: c]

## 查询

1. LHS 查询 左侧 **变量赋值或写入内存** 想象成 将文本保存到硬盘中
   试图找到变量的容器本身，从而可以对其赋值 赋值操作的目标是谁
   
2. RHS 查询 非左侧  **变量查找或从内容中读取** 想象成从硬盘打开文本文件
   查找某个变量的值  谁是赋值操作的源头

   都会在所有作用域中查询 
   严格模式下("use strict")，找不到所需的变量，引擎会ReferenceError 异常
   非严格模式下，LHS会自动创建一个全局变量
   查询成功后，如果对变量的值进行不合理的操作，TypeError

```js
  function foo(a) { //LHS yic
    console.log( a ); // 2 RHS
  }
  foo( 2 ); //RHS
```