### 1. js的数据类型

- 基本数据类型 :直接存储在栈(stack)中，占据空间小，大小固定，属于被频繁使用的数据

1. **undefined** ： 已声明 未赋值 => 未定义
2.  **null**： 代表空对象 空指针 主要用于赋值给一些可能会返回对象的变量，作为初始化。
3. **boolean**
4. **number**
5. **string**
6. **symbol**(es6新增)：唯一值，symbol作为属性值的时候，他它不可被枚举,所以不能使用for...in ... 来循环这个数据的属性
7. **bigInt** (es10新增) ：bigint 是一种内置对象，它提供一种方法来存储大于Number存储的数值，它在数据后面加一个n，并且可以表示任意大的整数

-  引用数据类型：同时存储在**栈**（stack）和**堆**（heap）中，占据空间大、大小不固定。

  存储的是该对象在栈中引用，真实的数据存放在堆内存里

  引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址,当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。

  ![图片描述](https://segmentfault.com/img/bVbrl5N?w=459&h=347)

  
  
  object( function、Array、Date等)
  

### 2. JS中数据类型的判断

问：数据类型有哪些 ？类型判断有哪些 优缺点？

1. **typeof`**:对于对象，除了function.都会显示出object,所有`typeof`并不能准确判断。可来判断一个对象的正确类型。

   - 对于非 Object的基本数据类型，除了null，均可判断

   - 对于null 返回 object

     null不是对象，尽管 typeof null = object 。

     因为这是 js 一个久远的bug，js诞生以来便如此。在js最初实现时，值是由一个表示类型的标签和实际数据表示的，而对象的标签是 0。又因为null 代表的是空指针，标签也是0，所以 typeof null 是 'object'。因此 null 不是 对象。

   - 对于引用数据类型，除了function，都返回object

   - 对于function 返回 function

   - typeof(typeof a) 返回 string

```javascript
console.log(typeof 2);               // number
console.log(typeof true);            // boolean
console.log(typeof 'str');           // string
console.log(typeof []);              // object     []数组的数据类型在 typeof 中被解释为 object
console.log(typeof function(){});    // function
console.log(typeof {});              // object
console.log(typeof undefined);       // undefined
console.log(typeof null);            // object     null 的数据类型被 typeof 解释为 object

```

2. **`instanceof`**: instanceof可以精准判断引用数据类型（Array，Function，Object），但是基本数据类型不能被instanceof精准判断。

   A instanceof B 就是用来判断B的原型是否在A的原型链上

3. **`constructor`**

4. **`Object.prototype.toString.call()` **最全面

Array数组对象、Math方法、String方法、date日期对象的方法。

#### 类型转换的方法有哪些，转字符串类型，转number类型的方法

toString()

parseInt()和parseFloat()

### 3. js异步处理的三种方式

```
 	javascript语言的执行环境是"单线程"(single thread)，就是指一次只能完成一件任务。如果有多个任务，就必须排队，等前面一个任务完成，再执行后面一个任务，以此类推。但是如果执行的是读取文件或者ajax操作等的异步操作呢，文件的读取都需要一定时间。

解决：同步和异步
- 同步：指在 主线程上排队执行的任务，只有前一个任务执行完毕，才能继续执行下一个任务。必须等这个调用 返回结果才能继续往后执行。程序的执行顺序和任务排列顺序是一致的。
- 异步：异步任务是指不进入主线程，而进入 任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程。
```

```javascript
异步处理：
1. 回调函数:被作为实参传入另一函数，并在该外部函数内被调用，用以来完成某些任务的函数
从文件系统中读取一个./pakage.json文件并写入./p.json,读取成功两秒后输出'ok'。
    const fs = require('fs')
    fs.readFile('./pakage.json',(err,info) => {
        fs.writeFile('./p.json',info,(err) => {
            if(!err) {
                setTimeout(() => {
                    console.log('ok')
                },2000)
            }
        })
    })

2. promise
3. async+await 
    async function run() {
        let info = await promise1;
        await promise2(info);
        await promise3(2000);
        console.log('ok');
    }
```

### 4. 原生js中操作DOM的方法

DOM节点分为三大类: 元素节点(标签节点)、属性节点和文本节点。

```javascript
1. js中获取dom元素的方式
//通过ID
var li = document.getElementById(“first”);
//通过类名
var lis1 = document.getElementsByClassName(“cls”);
//通过name属性
var lis2 = document.getElementsByName(“name”);
//通过标签名
var lis3 = document.getElementsByTagName(“li”);
2.获取节点
1）parentNode: 获取当前节点的父节点
2） childNodes： 获取当前节点的所有子节点（包括元素节点和文本节点）
children： 获取当前节点的所有元素子节点（不包含文本节点）
3）firstChild： 获取第一个子节点，包括回车等文本节点
firstElementChild： 获取第一个元素节点。 不含文本节点
firstElementChild： 获取第一个元素节点。 不含文本节点
4）lastChild： 获取最后一个子节点，包括回车等文本节点
lastElementChild： 获取最后一个子节点，不含文本节点
5）previousSibling： 获取当前节点的前一个兄弟节点，包括文本节点
previousElementSibling： 获取当前节点的前一个元素兄弟节点
6）nextSibling：获取当前节点的后一个兄弟节点，包括文本节点
nextElementSibling：获取当前节点的后一个元素兄弟节点
7）attributes: 获取当前节点的所有属性节点。 返回数组格式 
```



### 5. == 和===的区别

```javascript
1. == 比较运算 会进行数据类型转换
会在进行比较之前，将两个操作数转换成相同的类型
 1   ==  1     // true
"1"  ==  1     // true
 1   == '1'    // true
 0   == false  // true

2. === 严格比较运算  不会进行数据类型转换
仅当两个操作数的类型相同且值相等为 true
3 === 3   // true
3 === '3' // false
var object1 = {"value":"key"}, object2={"value":"key"};
object1 === obj ect2 //false
```



### 6.  如何对多个事件进行处理？

-  有一万个 li 节点 给这些节点绑上事件？ 事件代理

  ~~~markdown
  事件代理：冒泡 捕获
      利用冒泡特点 只有一个事件绑定 监听未来的元素 节点多采取
      父节点可以监听 子节点的点击事件 （子节点点击 父节点也会收到这个click 事件）
      ```html
      <ul>
          <li>111</li>
          <li>222</li>
          <li>333</li>
          <!-- 3s 之后在下面插入 一个li -->
      </ul>
      ```
  ~~~

- 全局事件（定时器） 一定要清理

###  6. 事件委托是什么？

**事件委托** 本质上是利用浏览 器事件**冒泡**的机制，事件在在冒泡过程中会上传到**父节点**，父节点可通过事件对象获取到 **目标节点**，=>  把**子节点的监听事件定义在父节点上**，**由父节点的监听事件统一处理多个子元素的事件 **=>  称为 事件代理。

使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的**动态绑定**，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给**父元素中的监听事件**来处理。

### 7. 什么是事件捕获？

![img](https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=2269261448,2123572753&fm=26&gp=0.jpg)

捕获阶段：window----> document----> html----> body ---->目标元素

冒泡阶段：当前元素---->body ----> html---->document ---->window





