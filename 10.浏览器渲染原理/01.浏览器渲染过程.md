# 浏览器渲染原理

我们知道执行 JS 有一个 JS 引擎，那么执行渲染也有一个渲染引擎。同样，渲染引擎在不同的浏览器中也不是都相同的。比如在 Firefox 中叫做 **Gecko**，在 Chrome 和 Safari 中都是基于 **WebKit** 开发的。在这一章节中，我们也会主要学习关于 **WebKit** 的这部分渲染引擎内容。

## 1. 浏览器接收到 HTML 文件并转换为 DOM 树

- 当我们打开一个网页时，浏览器都会去请求对应的 HTML 文件。虽然平时我们写代码时都会分为 JS、CSS、HTML 文件，也就是字符串，但是计算机硬件是不理解这些字符串的，所以在网络中传输的内容其实都是 `0` 和 `1` 这些**字节数据**。当浏览器接收到这些字节数据以后，它会将这些**字节数据转换为字符串**，也就是我们写的代码。
- 当数据转换为字符串以后，浏览器会先将这些字符串通过词法分析转换为**标记**（token)，这一过程在词法分析中叫做**标记化**（tokenization）。
- 这一过程将代码拆分成一块一块，并给内容打上标记。
- 标记结束后，这些标记会紧着着转换为Node,然后根据Node之间的联系构建为一颗DOM树。

![img](https://user-gold-cdn.xitu.io/2018/11/27/1675416cbea98c3c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

以上就是浏览器从网络中接收到 HTML 文件然后一系列的转换过程：

总结：(1)当我们打开一个网页时，浏览器都会去请求对应的 HTML 文件，虽然我们平时会将代码分为JS HTML CSS文件，但是计算机不理解这些字符串.

(2)所有在网络中传输的内容都是0和1这些字节数据，

(3)然后将字节数据转换为字符串。

(3)然后浏览器会给这些字符串标记化，就是将代码拆分成一块一块，并给内容打上标记。

(4)然后标记转换为Node 最后根据node之间的联系构建一颗DOM树。

![img](https://user-gold-cdn.xitu.io/2018/11/27/167542b09875a74a?imageslim)

## 2. 将 CSS 文件转换为 CSSOM 树

其实转换 CSS 到 CSSOM 树的过程和上一小节的过程是极其类似的。**为什么会消耗资源**

![img](https://user-gold-cdn.xitu.io/2018/11/27/167542a9af5f193f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

在这一过程中，浏览器会确定下每一个节点的**样式**到底是什么，并且这一过程其实是**很消耗资源**的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得**递归** CSSOM 树，然后确定具体的元素到底是什么样式。

层层递归找，很复杂。我们应该尽可能的避免写**过于具体**的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证**层级扁平**。

## 3. 生成渲染树

当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树

![img](https://user-gold-cdn.xitu.io/2018/11/27/16754488529c48bd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- 在这一过程中，不是简单的将两者合并就行了。渲染树只会包括**需要显示的节点**和**这些节点的样式信息**，如果某个节点是 `display: none` 的，那么就不会在渲染树中显示。

- 当浏览器生成渲染树以后，就会根据渲染树来进行**布局**（也可以叫做回流），然后调用 **GPU 绘制**，**合成图层**，**显示**在屏幕上。

  

  通过以上内容，我们已经详细了解到了浏览器从接收文件到将内容渲染在屏幕上的这一过程。

## 4. 为什么操作 DOM 慢

因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行**线程之间的通信**，并且操作 DOM 可能还会带来**重绘回流**的情况，所以也就导致了性能上的问题。

> 经典面试题：插入几万个 DOM，如何实现页面不卡顿？

解决办法：**虚拟滚动**

**这种技术的原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。**

## 5. 重绘（Repaint）和回流（Reflow）

重绘和回流会在我们**设置节点样式**时频繁出现，同时也会很大程度上**影响性能**。

- 重绘：是当节点需要**更改外观而不会影响布局**的，比如改变 `color` 就叫称为重绘
- 回流：是**布局或者几何属性**需要改变 

回流**必定**会发生重绘，重绘**不一定**会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。

以下几个动作可能会导致性能问题：

- 改变 `window` 大小
- 改变字体
- 添加或删除样式
- 文字改变
- 定位或者浮动
- 盒模型

并且很多人不知道的是，重绘和回流其实也和 Eventloop 有关。

1. 当 Eventloop 执行完 Microtasks 后，会判断 `document` 是否需要更新，因为浏览器是 60Hz 的刷新率，每 16.6ms 才会更新一次。
2. 然后判断是否有 `resize` 或者 `scroll` 事件，有的话会去触发事件，所以 `resize` 和 `scroll` 事件也是至少 16ms 才会触发一次，并且自带节流功能。
3. 判断是否触发了 media query
4. 更新动画并且发送事件
5. 判断是否有全屏操作事件
6. 执行 `requestAnimationFrame` 回调
7. 执行 `IntersectionObserver` 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好
8. 更新界面
9. 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 `requestIdleCallback` 回调。

接下来我们将会来学习如何减少重绘和回流的次数。

### 5.1 减少重绘和回流（重排）

- 使用 `transform` 替代 `top`:transform 实现动画效果，可以避开重排和回流阶段，直接在非主线程上执行合成动画操作，相对于重绘和，回流合成能大大提升绘制效率。
- 使用 `visibility` 替换 `display: none` ，因为前者只会引起重绘，后者会引发回流（改变了布局）
- 不要把节点的属性值放在一个循环里当成循环里的变量

```javascript
for(let i = 0; i < 1000; i++) {
    // 获取 offsetTop 会导致回流，因为需要去获取正确的值
    console.log(document.querySelector('.test').style.offsetTop)
}
```

- 不要使用 `table` 布局，可能很小的一个小改动会造成整个 `table` 的重新布局
- 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 `requestAnimationFrame`
- CSS 选择符**从右往左**匹配查找，避免节点层级过多
- 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 `video` 标签来说，浏览器会自动将该节点变为图层。生成新图层方式(will-change、`video`、`iframe` 标签)。

## 6. 参考文章：

浏览器渲染器过程：https://www.jianshu.com/p/6335e46e2ace

浏览器渲染原理：https://juejin.im/book/6844733763675488269/section/6844733763771957256

