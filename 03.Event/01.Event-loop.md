##  **Event-loop 事件循环**

### JavaScript的执行原理

- JavaScript是单线程，同一时间只能做一件事情。

  单线程意味着**所有的任务**需要排队，前一个任务结束，才会执行后一个任务。

- **所有的任务**分两种：为了防止执行阻塞 ，有了同步任务和异步任务。

  **同步任务**：在主线程上排队执行，只有前一个任务执行完毕，才执行后一个任务。=> 形成**“执行栈”**

  **异步任务**：不进入主线程，而是进入**"消息队列"**里面，当**某个异步任务**可以执行时,即得到异步任务的结果时，放入队列里面等待同步任务执行完，消息队列通知主线程，则该任务进入主线程执行。 => **"消息队列"**

- 异步任务的执行机制：所有**同步任务**都在主线程上执行，形成一**“执行栈”**。另外还有一个**消息队列**，一旦**“执行栈”**中的所有**同步任务**执行完毕，系统就会读取**"消息队列"**里面的**异步任务**，结束等待状态，进入执行栈，开始执行。

### Event-loop(事件循环)

主线程从**任务队列**里面读取事件，循环不断，整个运行机制称为Event-loop(事件循环)。也可以理解为 浏览器协调用户交互，渲染，网络等任务叫做Event-loop。

- macro-task （宏任务: 由宿主环境引起的任务 ）

  包括整体代码script，setTimeout，setInterval，   I/O， UI render

  1. setTimeout、

  2. 整体的一段script

  3. 渲染事件(如解析DOM、 计算布局、绘制) ;

  4. 用户交互事件(如鼠标点击、滚动页面、放大缩小等) ;

  5. JavaScript脚本执行事件; ( setTimeout)

  6. 网络请求完成、文件读写完成事件。

  7. 主线程采用一个for循环，不断地从这些任务队列中取出任务并执行任务。

- micro-task(微任务: 由js本身引起的任务）

  1. 基于微任务的技术有MutationObserver、 Promise 以及以Promise 为基础开发出来的很多其他的技术。Process . nextTick(node端)
2. 微任务就是一个 需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。
  3. 微任务可以在实时性和效率之间做一个有效的权衡。


- 事件循环流程：

  整体代码(script)作为宏任务，进入主线程，遇到同步的代码，按顺序执行。

  遇到宏任务，把它放入宏任务队列中，遇到微任务，把它放入微任务队列中。

  当同步代码执行完毕时，取出微任务队列中**所有的**微任务执行。

  如果执行过程中又产生了微任务，继续执行微任务，直到本次宏任务中的所有微任务执行完毕。然后来到宏任务队列。

只要宏任务队列不为空：

1. 从宏任务队列取出 **一个** 执行

2. 从微任务队列里面取出 **所有的** 执行，如果在这执行过程中又产生了微任务，再次重复第二步。

3. 有可能进入浏览器的重新渲染。

   reqAnimationframe 回调

   执行 IntersectionObserver 回调

   重新绘制渲染

### 补充

1. 以60fps 帧 ，每一帧花费 16.6666ms

2. 我们的渲染是: 一个宏任务 -> 清空微任务 -> 渲染 -> 一个宏任务 -> 清空微任务 -> 渲染

3. 定时器：setTimeout()和setInterval()，前者指定的代码是一次性执行，后者则为反复执行。

   setTimeout()接受两个参数，第一个是回调函数，第二个是推迟执行的毫秒数

   将setTimeout()的第二个参数设为0，表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。

### 参考：

阮一峰：http://www.ruanyifeng.com/blog/2014/10/event-loop.html